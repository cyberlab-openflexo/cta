use org.openflexo.foundation.fml.rt.FMLRTVirtualModelInstanceModelSlot;

/**
 * 
 * @author sylvain
 * @version 0.1
 */
@VirtualModel(uri="http://ensta-bretagne.fr/cyber/cta/CTA.fml")
public class CTA {

  public PimCA pimca;
  public SystemNode rootNode;
  public TSM tsm;
  @GetSetProperty(value="executions", access=get)  
  public List<VirtualModelInstanceType<Execution>> getExecutions {  
    return this.FML@RT::SelectVirtualModelInstance();  
  }

  @CreationScheme  
  CTA:init() {  
    pimca = PimCA.create();    
    tsm = TSM.init("ExecutionModel");    
    rootNode = SystemNode.create("System");  
  }  

  @ActionScheme  
  VirtualModelInstanceType<Execution> startNewSimulation(String simulationName, String description) {  
    return Execution.create(parameters.simulationName,parameters.description);  
  }  


  @FlexoConcept  
  public class SystemNode {  
  
    public PimCAModel pimcaModel;  
    public List diagrams;  
      
    public VirtualModelInstanceType<PimCADiagram> defaultDiagram = diagrams.get(0);  
    public String nodeName;  
    @GetSetProperty(value="machineryAllocations", access=get)    
    public List<FlexoConceptInstanceType<MachineryAllocation>> getMachineryAllocations {    
      return container.SelectFlexoConceptInstance(type=MachineryAllocation);    
    }  
    public SystemNode parentNode;  
    public List childrenNodes;  
    public SystemNodeExecutionDefinition systemNodeExecutionDefinition;  
  
    @CreationScheme    
    SystemNode:create(String nodeName) {    
      pimcaModel = PimCAModel.create();      
      nodeName = parameters.nodeName;      
      this.createNewDiagram(("DefaultDiagramFor" + pimcaModel.name),"Default diagram","")      
      systemNodeExecutionDefinition = SystemNodeExecutionDefinition.create(nodeName);    
    }    
  
    @ActionScheme    
    VirtualModelInstanceType<PimCADiagram> createNewDiagram(String diagramName, String diagramTitle, String diagramDescription) {    
      log ("Create new diagram " + parameters.diagramName)      
      VirtualModelInstanceType<PimCADiagram> newDiagram = PimCADiagram.init(parameters.diagramName,pimcaModel,parameters.diagramTitle);      
      diagrams.add(newDiagram)      
      return newDiagram;    
    }    
  
    @ActionScheme    
    Void allocateExistingExecutionUnit(FlexoConceptInstanceType<Machinery> machinery, UndefinedFlexoConceptInstanceType executionUnit) {    
      this.getMachineryAllocation(parameters.machinery).allocateExistingExecutionUnit(parameters.executionUnit)    
    }    
  
    @ActionScheme    
    Void allocateNewGuardActionExecutionUnit(FlexoConceptInstanceType<Machinery> machinery, String executionUnitName) {    
      this.getMachineryAllocation(parameters.machinery).allocateNewGuardActionExecutionUnit(parameters.executionUnitName)    
    }    
  
    @ActionScheme    
    FlexoConceptInstanceType<MachineryAllocation> getMachineryAllocation(FlexoConceptInstanceType<Machinery> machinery) {    
      FlexoConceptInstanceType<MachineryAllocation> returned = container.SelectUniqueFlexoConceptInstance(type=MachineryAllocation,where=where=(selected.machinery = parameters.machinery));      
      if (returned = null) {      
        returned = MachineryAllocation.create(parameters.machinery);      
      }      
      return returned;    
    }    
  
    @ActionScheme    
    public Void update() {    
      log ("Updating " + this)      
      MatchingSet matchingSet = this.initiateMatching(MachineryAllocation);      
      for (machinery : pimcaModel.SelectFlexoConceptInstance(type=Machinery)) {      
        FML@RT::MatchFlexoConceptInstance as MachineryAllocation match=(machinery=machinery) using MachineryAllocation:create(machinery)      
      }      
      matchingSet.finalizeMatching()    
    }    
  
    @EventListener    
    Void newMachinery() {    
      this.update()    
    }    
  
    @EventListener    
    Void deletedMachinery() {    
      this.update()    
    }    
  
    @ActionScheme    
    Void updateConnections() {    
      for (machineryAllocation : machineryAllocations) {      
        for (machineryConnection : machineryAllocation.machineryConnections) {        
          machineryConnection.updateReference()        
        }      
      }    
    }    
  
  
    @FlexoConcept    
    public class MachineryAllocation {    
      
      public Machinery machinery;    
      public ExecutionUnitDefinition executionUnitDefinition;    
      @GetSetProperty(value="machineryConnections", access=get)      
      public List<FlexoConceptInstanceType<MachineryConnection>> getMachineryConnections {      
        return container.container.SelectFlexoConceptInstance(type=MachineryConnection);      
      }    
      
      @CreationScheme      
      MachineryAllocation:create(FlexoConceptInstanceType<Machinery> aMachinery) {      
        machinery = parameters.aMachinery;        
        container.firePropertyChange machineryAllocations      
      }      
      
      @DeletionScheme      
      Void delete() {      
          
      }      
      
      @ActionScheme      
      Void allocateExistingExecutionUnit(UndefinedFlexoConceptInstanceType executionUnitDefinition) {      
        executionUnitDefinition = parameters.executionUnitDefinition;      
      }      
      
      @ActionScheme      
      FlexoConceptInstanceType<ExecutionUnitDefinition> allocateNewGuardActionExecutionUnit(String executionUnitName) {      
        executionUnitDefinition = GuardActionExecutionUnitDefinition.create(parameters.executionUnitName);        
        container.updateConnections()        
        return executionUnitDefinition;      
      }      
      
      @ActionScheme      
      public Void clearAllocation() {      
        executionUnitDefinition = null;      
      }      
      
      @ActionScheme      
      FlexoConceptInstanceType<MachineryConnection> createMachineryConnection(String referenceName, FlexoConceptInstanceType<Relation> relation, FlexoConceptInstanceType<MachineryAllocation> reference) {      
        FlexoConceptInstanceType<MachineryConnection> returned = MachineryConnection.create(parameters.referenceName,parameters.relation,parameters.reference);        
        return returned;      
      }      
      
      
      @FlexoConcept      
      public class MachineryConnection {      
          
        public String referenceName;      
        public MachineryAllocation reference;      
        public Relation relation;      
        public ExecutionUnitReference executionUnitReference;      
          
        @CreationScheme        
        MachineryConnection:create(String referenceName, FlexoConceptInstanceType<Relation> relation, FlexoConceptInstanceType<MachineryAllocation> reference) {        
          referenceName = parameters.referenceName;          
          relation = parameters.relation;          
          reference = parameters.reference;          
          executionUnitReference = ExecutionUnitReference.create(parameters.referenceName,parameters.reference.executionUnitDefinition.supportConcept,("Reference to " + parameters.reference.machinery.name));        
        }        
          
        @DeletionScheme        
        Void delete() {        
              
        }        
          
        @ActionScheme        
        Void updateReference() {        
          log ("Mise a jour de la reference pour " + reference)          
          log ("Le type est maintenant: " + reference.executionUnitDefinition.supportConcept)          
          executionUnitReference.property.flexoConceptType = reference.executionUnitDefinition.supportConcept;        
        }        
          
      }      
      
    }    
  
  }  

  @FlexoConcept  
  public class MachineryAllocation {  
  
    public Machinery machinery;  
    public ExecutionUnitDefinition executionUnitDefinition;  
    @GetSetProperty(value="machineryConnections", access=get)    
    public List<FlexoConceptInstanceType<MachineryConnection>> getMachineryConnections {    
      return container.container.SelectFlexoConceptInstance(type=MachineryConnection);    
    }  
  
    @CreationScheme    
    MachineryAllocation:create(FlexoConceptInstanceType<Machinery> aMachinery) {    
      machinery = parameters.aMachinery;      
      container.firePropertyChange machineryAllocations    
    }    
  
    @DeletionScheme    
    Void delete() {    
      
    }    
  
    @ActionScheme    
    Void allocateExistingExecutionUnit(UndefinedFlexoConceptInstanceType executionUnitDefinition) {    
      executionUnitDefinition = parameters.executionUnitDefinition;    
    }    
  
    @ActionScheme    
    FlexoConceptInstanceType<ExecutionUnitDefinition> allocateNewGuardActionExecutionUnit(String executionUnitName) {    
      executionUnitDefinition = GuardActionExecutionUnitDefinition.create(parameters.executionUnitName);      
      container.updateConnections()      
      return executionUnitDefinition;    
    }    
  
    @ActionScheme    
    public Void clearAllocation() {    
      executionUnitDefinition = null;    
    }    
  
    @ActionScheme    
    FlexoConceptInstanceType<MachineryConnection> createMachineryConnection(String referenceName, FlexoConceptInstanceType<Relation> relation, FlexoConceptInstanceType<MachineryAllocation> reference) {    
      FlexoConceptInstanceType<MachineryConnection> returned = MachineryConnection.create(parameters.referenceName,parameters.relation,parameters.reference);      
      return returned;    
    }    
  
  
    @FlexoConcept    
    public class MachineryConnection {    
      
      public String referenceName;    
      public MachineryAllocation reference;    
      public Relation relation;    
      public ExecutionUnitReference executionUnitReference;    
      
      @CreationScheme      
      MachineryConnection:create(String referenceName, FlexoConceptInstanceType<Relation> relation, FlexoConceptInstanceType<MachineryAllocation> reference) {      
        referenceName = parameters.referenceName;        
        relation = parameters.relation;        
        reference = parameters.reference;        
        executionUnitReference = ExecutionUnitReference.create(parameters.referenceName,parameters.reference.executionUnitDefinition.supportConcept,("Reference to " + parameters.reference.machinery.name));      
      }      
      
      @DeletionScheme      
      Void delete() {      
          
      }      
      
      @ActionScheme      
      Void updateReference() {      
        log ("Mise a jour de la reference pour " + reference)        
        log ("Le type est maintenant: " + reference.executionUnitDefinition.supportConcept)        
        executionUnitReference.property.flexoConceptType = reference.executionUnitDefinition.supportConcept;      
      }      
      
    }    
  
  }  

  @FlexoConcept  
  public class MachineryConnection {  
  
    public String referenceName;  
    public MachineryAllocation reference;  
    public Relation relation;  
    public ExecutionUnitReference executionUnitReference;  
  
    @CreationScheme    
    MachineryConnection:create(String referenceName, FlexoConceptInstanceType<Relation> relation, FlexoConceptInstanceType<MachineryAllocation> reference) {    
      referenceName = parameters.referenceName;      
      relation = parameters.relation;      
      reference = parameters.reference;      
      executionUnitReference = ExecutionUnitReference.create(parameters.referenceName,parameters.reference.executionUnitDefinition.supportConcept,("Reference to " + parameters.reference.machinery.name));    
    }    
  
    @DeletionScheme    
    Void delete() {    
      
    }    
  
    @ActionScheme    
    Void updateReference() {    
      log ("Mise a jour de la reference pour " + reference)      
      log ("Le type est maintenant: " + reference.executionUnitDefinition.supportConcept)      
      executionUnitReference.property.flexoConceptType = reference.executionUnitDefinition.supportConcept;    
    }    
  
  }  

}
